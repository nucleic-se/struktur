{
  "id": "build-performance",
  "class": "blog_post",
  "title": "Optimizing Build Performance",
  "slug": "build-performance",
  "description": "Tips for faster builds on large stacks",
  "$aspects": {
    "blog_post": {
      "date": "2025-12-10",
      "content": "Struktur is fast by default—Skribe builds 16 posts with tag indexes in under a second. But as your stack grows to hundreds or thousands of instances, performance optimization matters. Here's how to keep builds fast.\n\n**Minimize template complexity.** Every nested loop multiplies execution time. If you have a template that iterates over all instances, then for each instance iterates over all tags, then for each tag iterates over all instances again... you've got O(n³) complexity. Move that logic to helpers. Pre-compute relationships. Use efficient built-in helpers like `where_includes` instead of manual filtering.\n\n**Structure classes wisely.** Deep inheritance chains (5+ levels) slow down class resolution. Keep hierarchies shallow. Use composition (mixins, instance overrides) instead of deep inheritance. The class loader needs to walk up the chain and merge fields at each level—fewer levels means faster loading.\n\n**Cache intelligently.** The canonical.json file is your friend. It contains all merged, validated data. If your inputs haven't changed, you don't need to rebuild it. Check file timestamps or use a build system that tracks dependencies. Only rebuild when source files actually change.\n\n**Use mixins strategically.** Don't duplicate base stacks. Use `--classes-from` and `--templates-from` to layer sources. This keeps total file count lower and reduces redundant loading. A 100-file base plus a 10-file mixin is faster to load than a 110-file monolithic stack.\n\n**Profile with NODE_ENV=production.** This enables optimizations in Node.js and any dependencies. Development mode includes extra checks and debugging hooks that slow things down. Profiling in production mode shows you real deployment performance.\n\nThe biggest wins come from **avoiding redundant file generation**. If you're generating 1000 files but only 10 changed, don't regenerate everything. Use manifest tracking to know what's already built. Struktur's determinism makes this safe—if inputs haven't changed, outputs won't either.",
      "tags": [
        "advanced",
        "best-practices"
      ]
    }
  }
}
