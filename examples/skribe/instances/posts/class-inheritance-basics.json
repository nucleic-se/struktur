{
  "$id": "class-inheritance-basics",
  "$class": "blog_post",
  "title": "Class Inheritance Made Simple",
  "slug": "class-inheritance-basics",
  "description": "Understanding how classes extend each other in Struktur",
  "$aspects": {
    "aspect_blog_post": {
      "date": "2025-12-01",
      "content": "Class inheritance is one of Struktur's most powerful features. When a class extends another, it inherits all fields and schemas. This lets you build hierarchies that make sense\u2014start general, get specific.\n\nIn Skribe, we have content_base as the foundation. It defines what ALL content needs: an id, title, slug, and description. These are universal requirements. Then blog_post extends content_base and adds blog-specific fields like date, author, and tags. The page class also extends content_base but adds the menu field instead. Each child inherits everything from its parent plus its own unique properties.\n\nThe beauty here is **validation flows down the hierarchy**. If content_base requires a title, every class that extends it must also have a title. Struktur validates this at build time using schema compatibility checks. You can't accidentally make a child class that breaks its parent's contract. This prevents a whole category of bugs where you forget required fields or change types incompatibly.\n\nThink of it as layering: start with a broad base that captures common concerns, then specialize as you go. Don't put blog-specific fields in content_base. Don't make the base too specific. Find the right level of abstraction for each class in your hierarchy.\n\nThe parent chain is resolved deterministically\u2014Struktur walks up from child to parent, merging fields and schemas at each level. By the time an instance is validated, it's checked against the complete merged schema from the entire inheritance chain. Clean, predictable, and safe.",
      "tags": [
        "tutorial",
        "concepts"
      ]
    }
  }
}
