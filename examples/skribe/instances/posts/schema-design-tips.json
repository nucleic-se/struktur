{
  "id": "schema-design-tips",
  "class": "blog_post",
  "title": "Schema Design Best Practices",
  "slug": "schema-design-tips",
  "description": "How to design robust JSON schemas for your classes",
  "aspects": {
    "blog_post": {
      "date": "2025-12-07",
      "content": "Good schemas prevent bugs before they happen. Bad schemas let errors slip through until production. Here's how to design schemas that catch problems early.\n\n**Use additionalProperties: false religiously.** This is the typo detector. If your schema defines fields [title, date, author] and someone adds 'auther' by mistake, the build fails. Without this setting, the typo silently passes validation and your template gets undefined values. Always be strict.\n\n**Mark required fields explicitly.** Don't rely on defaults or assumptions. If blog posts MUST have dates, put 'date' in the required array. This makes the contract explicit and enforceable. Optional fields should be truly optional, with templates prepared to handle their absence.\n\n**Use enums for constrained values.** If menu can only be 'header', 'footer', 'both', or 'none', define an enum. This catches typos and documents the valid options. It also enables better IDE autocomplete if you're using JSON schema tooling.\n\n**Add descriptions everywhere.** Future you (or your collaborators) will thank you. Descriptions document what fields mean, what values are acceptable, and why constraints exist. They're your schema's inline documentation.\n\n**Design for inheritance carefully.** Child schemas should extend parent constraints, not contradict them. If content_base requires a title, blog_post can't make it optional. If content_base allows title to be a string, blog_post can't change it to a number. Struktur validates schema compatibility across the inheritance chain and will fail the build if you violate these rules.\n\nThink of schemas as contracts that get stricter, never looser. Parents define minimum requirements. Children can add fields, narrow types (string|number → string), or add format constraints (string → string with date format). They can't relax requirements or widen types. This ensures substitutability—anywhere a parent class is expected, a child can be used safely.",
      "tags": [
        "best-practices",
        "concepts"
      ]
    }
  }
}
