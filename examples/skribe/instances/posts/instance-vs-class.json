{
  "id": "instance-vs-class",
  "class": "blog_post",
  "title": "Instances vs Classes: When to Use Which",
  "slug": "instance-vs-class",
  "description": "Understanding the difference between classes and instances",
  "aspects": {
    "blog_post": {
      "date": "2025-12-05",
      "content": "The class/instance split is fundamental to Struktur. If you're coming from other static site generators, this might feel unfamiliar. Most generators just have 'content files'—markdown with frontmatter. Struktur separates shape from data. Let me explain why.\n\n**Classes define shapes.** They say 'a blog post looks like this: it has a title (string), a date (string), an author (string), and tags (array of strings).' Classes specify field names, types, defaults, and validation rules. They live in classes/ and have companion .schema.json files. Think of them as blueprints or type definitions.\n\n**Instances are actual data.** They say 'here's a specific blog post with this title, this date, this content.' Instances reference a class and provide concrete values for each field. They live in instances/ and are just JSON objects with an id and class field. Think of them as the houses built from blueprints.\n\nThe separation has huge benefits. **Validation happens at the class level.** Define the schema once, validate all instances against it. **Defaults cascade through inheritance.** If content_base sets a default description, all blog posts inherit it unless they override. **Types are explicit.** No guessing whether tags is a string or array—the schema says it's an array.\n\nWhen you build, Struktur merges class definitions with instance data. For each instance, it walks up the class hierarchy, collects inherited fields, applies defaults, then overlays the instance's specific values. The result is validated against the merged schema. By the time templates render, every instance is complete, correct, and type-safe.\n\nThis is why Struktur can generate complex outputs deterministically. The data model is rigorous. Classes enforce structure. Instances provide content. Templates consume validated, predictable data. No runtime surprises.",
      "tags": [
        "concepts",
        "tutorial"
      ]
    }
  }
}
