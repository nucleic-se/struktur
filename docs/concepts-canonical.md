# Concepts: Canonical JSON

Understanding the canonical data model and structure.

## Overview

**Canonical JSON** is Struktur's intermediate data format—the fully merged, validated output before template rendering. It represents the complete, resolved state of your data model.

```
Classes + Instances → Merge → Validate → Canonical JSON → Render → Outputs
                                         ↑
                                    Complete data model
```

---

## What is Canonical?

Canonical JSON is:
- **Complete** - All instances fully merged with class defaults
- **Validated** - Passed all schema and constraint checks
- **Inspectable** - JSON file you can examine
- **Portable** - Can be used outside Struktur

**Generated by:**
```bash
# Build process (creates canonical.json automatically)
struktur build .

# Generate canonical without rendering
struktur generate -c classes/ -i instances/ -o canonical.json
```

---

## Canonical Structure

### Top-Level Shape

```json
{
  "$instances": [...],
  "$instances_by_id": {...},
  "$classes": [...],
  "$classes_by_id": {...},
  "$class_names": [...],
  "$aspects": [...],
  "$aspects_by_id": {...},
  "$aspect_names": [...],
  "$metadata": {...},
  "$validation": {...}
}
```

### Field Descriptions

**`$instances`** (Array)
- All instances after merging
- Fully resolved with class defaults
- Validated against schemas

**`$instances_by_id`** (Object)
- Same instances, keyed by `id`
- Fast lookup by ID
- Used in templates: `{{lookup $instances_by_id "web-01"}}`

**`$classes`** (Array)
- All class definitions
- Includes inheritance information
- Schema references

**`$classes_by_id`** (Object)
- Classes keyed by class name
- Used for inheritance checks
- Available to helpers

**`$class_names`** (Array)
- List of unique class names
- Convenience for iteration and UI

**`$aspects`** (Array)
- All aspect definitions
- Schema and descriptive metadata

**`$aspects_by_id`** (Object)
- Aspects keyed by ID
- Fast aspect lookup

**`$aspect_names`** (Array)
- List of unique aspect names
- Convenience for iteration and UI

**`$metadata`** (Object)
- Build information
- Timestamp, version, generator

**`$validation`** (Object)
- Validation results (when generated with validation)

---

## Example Canonical JSON

### Simple Example

**Input:**

**`classes/service.schema.json`:**
```json
{
  "class": "service",
  "parent": null,
  "replicas": 1,
  "auto_restart": true,
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
      "port": { "type": "integer" },
      "replicas": { "type": "integer", "minimum": 1 },
      "auto_restart": { "type": "boolean" }
    }
  }
}
```

**`instances/web.json`:**
```json
{
  "id": "web-app",
  "class": "service",
  "port": 8080
}
```

**Output: `canonical.json`:**
```json
{
  "$instances": [
    {
      "id": "web-app",
      "class": "service",
      "port": 8080,
      "replicas": 1,
      "auto_restart": true
    }
  ],
  "$instances_by_id": {
    "web-app": {
      "id": "web-app",
      "class": "service",
      "port": 8080,
      "replicas": 1,
      "auto_restart": true
    }
  },
  "$classes": [
    {
      "class": "service",
      "parent": null,
      "replicas": 1,
      "auto_restart": true
    }
  ],
  "$classes_by_id": {
    "service": {
      "class": "service",
      "parent": null,
      "replicas": 1,
      "auto_restart": true,
      "_lineage": [],
      "_schema": "service.schema.json"
    }
  },
  "$class_names": ["service"],
  "$aspects": [],
  "$aspects_by_id": {},
  "$aspect_names": [],
  "$metadata": {
    "timestamp": "2025-12-16T10:30:00Z",
    "version": "0.2.3-alpha",
    "generator": "struktur",
    "count": 1,
    "classes": 1,
    "aspects": 0
  }
}
```

---

## $instances Array

Each instance in the array contains:

### Merged Fields

```json
{
  "id": "web-01",              // Instance ID
  "class": "server",           // Class name
  "hostname": "web-01",        // Instance-specific field
  "replicas": 1,               // From class default
  "auto_restart": true,        // From parent class default
  "domain": "@production",     // Tag reference
  "labels": ["web", "nginx"],  // Array field (merged)
  "$aspects": {                // Aspect data
    "monitoring": {
      "port": 9090
    }
  }
}
```

### Special Considerations

**Tag References:**
- Stored as strings: `"domain": "@production"`
- Not dereferenced in canonical
- Templates must look up if needed

**Array Merging:**
- Arrays from class + instance are concatenated
- Unless instance used `$reset`

**Null Values:**
- Null from class means "no default"
- Instance must provide value or schema allows null

---

## Classes Array

### Class Definition Structure

```json
{
  "class": "web_server",
  "parent": "server",
  "port": 80,
  "ssl": false,
  "_lineage": ["entity_base", "server", "web_server"],
  "_schema": "web_server.schema.json"
}
```

### Internal Fields

**`_lineage`** (Array)
- Full inheritance chain (root → leaf)
- Used by `inherits` helper
- Used by `class_lineage` helper

**`_schema`** (String)
- Schema filename
- Relative to class directory

---

## Aspects Array

### Aspect Definition Structure

```json
{
  "aspect": "monitoring",
  "description": "Monitoring configuration",
  "schema": {
    "type": "object",
    "properties": {
      "port": { "type": "integer" }
    },
    "required": ["port"]
  }
}
```

**Used for:**
- Aspect validation
- Template checks (`{{#if $aspects.monitoring}}`)
- Documentation generation

---

## Metadata Object

### Standard Fields

```json
{
  "timestamp": "2025-12-16T10:30:00.123Z",
  "version": "0.2.3-alpha",
  "generator": "struktur",
  "instance_count": 42,
  "class_count": 15,
  "aspect_count": 5
}
```

**Used for:**
- Build tracking
- Debugging
- Audit logs

---

## Using Canonical JSON

### Inspect Before Rendering

```bash
struktur generate -c classes/ -i instances/ -o debug.json
cat debug.json | jq .
```

**Use cases:**
- Debug merging issues
- Verify instance values
- Check class resolution

### Query with jq

```bash
# List all instance IDs
jq '."$instances"[] | .id' canonical.json

# Find instances by class
jq '."$instances"[] | select(.class == "server")' canonical.json

# Get class lineage
jq '."$classes_by_id".web_server._lineage' canonical.json

# Count by class
jq '[."$instances"[] | .class] | group_by(.) | map({class: .[0], count: length})' canonical.json
```

### Use in External Tools

Canonical JSON can be consumed by:
- Custom scripts
- Other build tools
- Data analysis tools
- Documentation generators

**Example Python script:**
```python
import json

with open('canonical.json') as f:
    data = json.load(f)

for instance in data['$instances']:
    if instance['class'] == 'server':
        print(f"{instance['id']}: {instance['hostname']}")
```

---

## Canonical Validation

Struktur validates canonical structure itself:

### Required Top-Level Fields

```json
{
  "$instances": [],      // Must exist
  "$instances_by_id": {},// Must exist
  "$classes": [],        // Must exist
  "$classes_by_id": {},  // Must exist
  "$metadata": {}        // Must exist
}
```

### Array Integrity

- `$instances` array matches `$instances_by_id` keys
- `$classes` array matches `$classes_by_id` keys
- No duplicate IDs

### Metadata Completeness

- timestamp present
- version present
- counts accurate

---

## Deterministic Canonical

Canonical JSON is deterministic:

**Same inputs always produce:**
- Same field order
- Same array order
- Same metadata (except timestamp)

**Benefits:**
- Diffable builds
- Version control friendly
- Reproducible builds

**Sort order:**
- Instances: by ID (alphabetical)
- Classes: by class name (alphabetical)
- Object keys: alphabetical

---

## Canonical in Templates

Templates receive canonical as context:

### Direct Access

```handlebars
{{!-- Access $instances array --}}
{{#each $instances}}
  <div>{{name}}</div>
{{/each}}

{{!-- Lookup by ID --}}
{{#with (lookup $instances_by_id "web-01")}}
  <h1>{{name}}</h1>
{{/with}}

{{!-- Check class inheritance --}}
{{#if (inherits class "entity_base" $classes_by_id)}}
  <span class="entity">{{name}}</span>
{{/if}}
```

### Build Metadata

```handlebars
<footer>
  <p>Generated: {{$metadata.timestamp}}</p>
  <p>Version: {{$metadata.version}}</p>
  <p>Total instances: {{length $instances}}</p>
</footer>
```

---

## Canonical Best Practices

### 1. Inspect After Changes

```bash
# After modifying classes or instances
struktur generate . -o test.json
jq . test.json
```

### 2. Version Control Canonical

For auditing, commit canonical.json:
```bash
struktur generate . -o canonical.json
git add canonical.json
git commit -m "Update canonical data model"
```

### 3. Diff Canonical Between Builds

```bash
struktur generate . -o before.json
# Make changes
struktur generate . -o after.json
diff before.json after.json
```

### 4. Use as API

Generate canonical, serve as JSON API:
```bash
struktur generate . -o public/api/data.json
# Now public/api/data.json is your API endpoint
```

---

## Canonical vs Build Output

### Canonical JSON

- Always generated (in build directory or specified path)
- Contains complete data model
- Machine-readable
- Portable, reusable

**Location:** `build/build-abc123/canonical.json`

### Template Outputs

- Generated from canonical
- Human-readable (HTML, YAML, etc.)
- Application-specific
- Based on templates

**Location:** `build/build-abc123/*.html`, `*.yml`, etc.

---

## Advanced Uses

### Generate Multiple Formats

```bash
# Generate canonical once
struktur generate . -o data.json

# Use canonical with different templates
struktur build --canonical data.json -t html-templates/
struktur build --canonical data.json -t yaml-templates/
struktur build --canonical data.json -t markdown-templates/
```

*(Note: --canonical flag is planned future feature)*

### Transform Canonical

```bash
# Generate canonical
struktur generate . -o canonical.json

# Transform with jq
jq '[."$instances"[] | select(.class == "server")]' canonical.json > servers.json

# Use transformed data elsewhere
```

### Validate Canonical Schema

Canonical follows a JSON Schema:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["$instances", "$instances_by_id", "$classes", "$classes_by_id", "$metadata"],
  "properties": {
    "$instances": { "type": "array" },
    "$instances_by_id": { "type": "object" },
    "$classes": { "type": "array" },
    "$classes_by_id": { "type": "object" },
    "$class_names": { "type": "array" },
    "$aspects": { "type": "array" },
    "$aspects_by_id": { "type": "object" },
    "$aspect_names": { "type": "array" },
    "$metadata": { "type": "object" },
    "$validation": { "type": "object" }
  }
}
```

---

## Troubleshooting

### Canonical Missing Fields

**Issue:** Expected field not in canonical instance

**Check:**
1. Field defined in class?
2. Field provided in instance?
3. Field name spelled correctly?
4. Check class lineage

```bash
jq '."$classes_by_id".myclass' canonical.json
```

### Canonical Has Unexpected Values

**Issue:** Field has wrong value

**Check merge order:**
```bash
# See all instances with same ID
grep -r '"id": "myinstance"' instances/
```

Later files override earlier files.

### Canonical Missing Metadata

**Issue:** metadata object incomplete

**Cause:** Canonical validation failed

**Fix:** Update Struktur or check canonical structure.

---

## See Also

- [Concepts: Build Pipeline](concepts-build-pipeline.md) - Where canonical fits
- [Concepts: Instances](concepts-instances.md) - Instance merging
- [Tutorial: First Stack](tutorial-first-stack.md) - Generate canonical
- [CLI Reference](cli-reference.md) - `generate` command
